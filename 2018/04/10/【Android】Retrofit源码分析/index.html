<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>【android】retrofit源码分析 | iTimeTraveler</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="Retrofit" />
  
  
  
  
  <meta name="description" content="Retrofit简介retrofit n. 式样翻新，花样翻新      vt. 给机器设备装配（新部件），翻新，改型 Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装。注意这里并没有说它是网络请求框架，主要原因在于网络请求的工作并不是 Retrofit 来完成的。Retrofit 2.0 开始内置 OkHttp，前者专注于接口的封装，后者专注于真正的网络请求。即通过 大">
<meta name="keywords" content="Retrofit">
<meta property="og:type" content="article">
<meta property="og:title" content="【Android】Retrofit源码分析">
<meta property="og:url" content="http://github.com/2018/04/10/【Android】Retrofit源码分析/index.html">
<meta property="og:site_name" content="iTimeTraveler">
<meta property="og:description" content="Retrofit简介retrofit n. 式样翻新，花样翻新      vt. 给机器设备装配（新部件），翻新，改型 Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装。注意这里并没有说它是网络请求框架，主要原因在于网络请求的工作并不是 Retrofit 来完成的。Retrofit 2.0 开始内置 OkHttp，前者专注于接口的封装，后者专注于真正的网络请求。即通过 大">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/android_common/retrofit.jpg">
<meta property="og:updated_time" content="2018-04-13T10:47:52.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【Android】Retrofit源码分析">
<meta name="twitter:description" content="Retrofit简介retrofit n. 式样翻新，花样翻新      vt. 给机器设备装配（新部件），翻新，改型 Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装。注意这里并没有说它是网络请求框架，主要原因在于网络请求的工作并不是 Retrofit 来完成的。Retrofit 2.0 开始内置 OkHttp，前者专注于接口的封装，后者专注于真正的网络请求。即通过 大">
<meta name="twitter:image" content="https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/android_common/retrofit.jpg">
  
    <link rel="alternate" href="/atom.xml" title="iTimeTraveler" type="application/atom+xml">
  

  

  <link rel="icon" href="/gallery/avatar/0.jpg">
  <link rel="apple-touch-icon" href="/gallery/avatar/0.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="../../../../css/style.css">

  <script src="../../../../js/jquery-3.1.1.min.js"></script>
  <script src="../../../../js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    <link rel="stylesheet" href="../../../../css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 border-width: 0px;  margin-top: 8px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="62px" height="75px" alt="Hike News" src="/gallery/avatar/0.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="../../../../index.html">首页</a> </li>
                
                  <li> <a class="main-nav-link" href="../../../../archives">归档</a> </li>
                
                  <li> <a class="main-nav-link" href="../../../../categories">分类</a> </li>
                
                  <li> <a class="main-nav-link" href="../../../../tags">标签</a> </li>
                
                  <li> <a class="main-nav-link" href="../../../../funnysite">酷站</a> </li>
                
                  <li> <a class="main-nav-link" href="../../../../collection">收藏</a> </li>
                
                  <li> <a class="main-nav-link" href="../../../../about">关于</a> </li>
                
                  <li> <a class="main-nav-link" href="../../../../mybooks">🎁</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '../../../../content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="../../../../js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-【Android】Retrofit源码分析" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
<div class="article-gallery">
  <div class="article-gallery-photos">
    
      <a class="article-gallery-img fancybox" href="https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/android_common/retrofit.jpg" rel="gallery_cjs6ynt83005jzf45oep6s2ey">
        <img src="https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/master/gallery/android_common/retrofit.jpg" itemprop="image">
      </a>
    
  </div>
</div>

    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      【Android】Retrofit源码分析
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="" class="article-date">
	  <time datetime="2018-04-10T14:20:55.000Z" itemprop="datePublished">2018-04-10</time>
	</a>

      
    <a class="article-category-link" href="../../../../categories/Android/">Android</a><a class="article-category-link" href="../../../../categories/Android/源码分析/">源码分析</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		阅读量<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

      

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Retrofit简介"><a href="#Retrofit简介" class="headerlink" title="Retrofit简介"></a>Retrofit简介</h3><p><code>retrofit</code> n. 式样翻新，花样翻新      vt. 给机器设备装配（新部件），翻新，改型</p>
<p><a href="http://square.github.io/retrofit/" target="_blank" rel="noopener"><strong>Retrofit</strong></a> 是一个 RESTful 的 HTTP 网络请求框架的封装。注意这里并没有说它是网络请求框架，主要原因在于网络请求的工作并不是 <code>Retrofit</code> 来完成的。<code>Retrofit</code> 2.0 开始内置 <a href="http://square.github.io/okhttp/" target="_blank" rel="noopener"><code>OkHttp</code></a>，前者专注于接口的封装，后者专注于真正的网络请求。即通过 大量的设计模式 封装了 <code>OkHttp</code> ，使得简洁易用。</p>
<p><img src="/gallery/android_common/4182937778-57515297dacff_articlex.png" alt=""></p>
<p>我们的应用程序通过 <code>Retrofit</code> 请求网络，实际上是使用 <code>Retrofit</code> 接口层封装请求参数、Header、Url 等信息，之后由 <code>OkHttp</code>完成后续的请求操作，在服务端返回数据之后，<code>OkHttp</code> 将原始的结果交给 <code>Retrofit</code>，后者根据用户的需求对结果进行解析的过程。Retrofit的大概原理过程如下：</p>
<ol>
<li><code>Retrofit</code> 将 <code>Http</code>请求 抽象 成 <code>Java</code>接口</li>
<li>在接口里用 注解 描述和配置 网络请求参数</li>
<li>用动态代理 的方式，动态将网络请求接口的注解 解析 成<code>HTTP</code>请求</li>
<li>最后执行<code>HTTP</code>请求</li>
</ol>
<p>这篇文章我将从Retrofit的基本用法出发，按照其使用步骤，一步步的探究Retrofit的实现原理及其源码的设计模式。</p>
<p>Retrofit Github: <a href="https://github.com/square/retrofit">https://github.com/square/retrofit</a></p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>使用 <code>Retrofit</code> 非常简单，首先需要在 build.gradle 中添加依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.squareup.retrofit2:retrofit:2.4.0'</span></span><br></pre></td></tr></table></figure>
<p>如果需要使用Gson解析器，也需要在build.gradle中添加依赖（后文会详细讲到Retrofit的Converter）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.squareup.retrofit2:converter-gson:2.0.2'</span></span><br></pre></td></tr></table></figure>
<h4 id="1-定义Interface"><a href="#1-定义Interface" class="headerlink" title="1. 定义Interface"></a>1. 定义Interface</h4><p>Retrofit使用java interface和注解描述了HTTP请求的API参数，比如Github的一个API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>其中Repo类定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Repo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-创建Retrofit实例"><a href="#2-创建Retrofit实例" class="headerlink" title="2. 创建Retrofit实例"></a>2. 创建Retrofit实例</h4><p>这样调用Retrofit就会为上面这个interface自动生成一个实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())		<span class="comment">//添加Gson解析器</span></span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure>
<h4 id="3-发起请求"><a href="#3-发起请求" class="headerlink" title="3. 发起请求"></a>3. 发起请求</h4><p>然后调用interface的具体方法时（这里是<code>listRepos()</code>）就构造好了一个<code>Call</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;List&lt;Repo&gt;&gt; call = service.listRepos(<span class="string">"octocat"</span>);</span><br></pre></td></tr></table></figure>
<p>返回的 <code>call</code> 其实并不是真正的数据结果，只是封装成了一个随时可以执行的请求，需要在合适的时机去执行它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步调用</span></span><br><span class="line">List&lt;Repo&gt; data = repos.execute(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步调用</span></span><br><span class="line">repos.enqueue(<span class="keyword">new</span> Callback&lt;List&lt;Repo&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response)</span> </span>&#123;</span><br><span class="line">                List&lt;Repo&gt; data = response.body();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>怎么样，有没有突然觉得请求接口就好像访问自家的方法一样简单？下面我们转入源码分析，按照使用步骤来探索Retrofit的实现原理。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>我们先来看看Retrofit的实例化步骤。先看看Retrofit这个类的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?, ?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> okhttp3.Call.Factory callFactory;	<span class="comment">// 生产网络请求器（Call）的工厂，默认使用OkHttp</span></span><br><span class="line">  <span class="keyword">final</span> HttpUrl baseUrl;	<span class="comment">// url地址</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;	<span class="comment">// 数据转换器（converter）工厂</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;	<span class="comment">// 生产网络请求适配器（CallAdapter）的工厂List</span></span><br><span class="line">  <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;	<span class="comment">// 回调方法执行器</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> validateEagerly;	<span class="comment">// 是否提前对业务接口中的注解进行验证转换的标志位</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,</span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; callAdapterFactories,</span><br><span class="line">      <span class="meta">@Nullable</span> Executor callbackExecutor, <span class="keyword">boolean</span> validateEagerly) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callFactory = callFactory;</span><br><span class="line">    <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">    <span class="keyword">this</span>.converterFactories = converterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">    <span class="keyword">this</span>.callAdapterFactories = callAdapterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    <span class="keyword">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">//...省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Retrofit的构造函数是package包可见的，并不是public的，所以外部并不能直接new，而是要通过<code>Retrofit.Builder</code>来实例化。</p>
<h4 id="Retrofit-Builder"><a href="#Retrofit-Builder" class="headerlink" title="Retrofit.Builder"></a>Retrofit.Builder</h4><p><code>Retrofit.Builder</code> 是 Retrofit 类中的一个子类，负责用来创建 Retrofit 实例对象，使用『Builder模式』的好处是清晰明了可定制化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Platform platform;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">    <span class="keyword">private</span> HttpUrl baseUrl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line">    Builder(Platform platform) &#123;</span><br><span class="line">      <span class="keyword">this</span>.platform = platform;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Retrofit支持Android Java8 默认Platform 三种平台，此处确认当前是在哪个平台环境运行</span></span><br><span class="line">      <span class="keyword">this</span>(Platform.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>Retrofit.Builder</code> 中的成员变量跟Retrofit中基本上是一一对应的，就不过多解释了。这里可以看到Builder的构造函数中默认判断了一下当前的运行平台。</p>
<p>最后，在创建 <code>Retrofit.Builder</code> 对象并进行自定义配置后，我们就要调用 <code>build()</code> 方法来构造出 <code>Retrofit</code> 对象了。那么，我们来看下 <code>build()</code> 方法里干了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 必须要配置baseUrl</span></span><br><span class="line">    <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base URL required."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认为 OkHttpClient</span></span><br><span class="line">    okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">    <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Android 平台下默认为 MainThreadExecutor</span></span><br><span class="line">    Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">    <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></span><br><span class="line">    List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">    <span class="comment">// 添加默认的 ExecutorCallAdapterFactory</span></span><br><span class="line">    callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a defensive copy of the converters.</span></span><br><span class="line">    List&lt;Converter.Factory&gt; converterFactories =</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">    <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">    <span class="comment">// 首先添加默认的 BuiltInConverters</span></span><br><span class="line">    converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">    converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">            unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>build()</code> 中，做的事情有：检查配置、设置默认配置、创建 <code>Retrofit</code> 对象。并且在执行 <code>.build()</code> 方法前，只有 <code>.baseUrl()</code> 是必须调用来设置访问地址的，其余方法则是可选的。同时我们可以看到设置了很多默认成员，但这里我们重点关注四个成员：<code>callFactory</code>，<code>callAdapter</code>，<code>responseConverter</code>和 <code>parameterHandlers</code>。</p>
<ol>
<li><code>callFactory</code> 负责创建 HTTP 请求，HTTP 请求被抽象为了 <code>okhttp3.Call</code> 类，它表示一个已经准备好，可以随时执行的 HTTP 请求；</li>
<li><code>callAdapter</code> 负责把 <code>retrofit2.Call&lt;?&gt;</code> 里的<code>Call</code>转换为 另一种类型<code>T</code>（注意和 <code>okhttp3.Call</code> 区分开来，<code>retrofit2.Call&lt;?&gt;</code> 表示的是对一个 Retrofit 方法的调用），这个过程会发送一个 HTTP 请求，拿到服务器返回的数据（通过 <code>okhttp3.Call</code> 实现），并把数据转换为声明的 <code>T</code> 类型对象（通过 <code>Converter&lt;F, T&gt;</code> 实现）；</li>
<li><code>responseConverter</code> 是 <code>Converter&lt;ResponseBody, T&gt;</code> 类型，负责把服务器返回的数据（JSON、XML、PB、二进制或者其他格式，由 <code>ResponseBody</code> 封装）转化为 <code>T</code> 类型的对象；</li>
<li><code>parameterHandlers</code> 则负责解析 API 定义时每个方法的参数，并在构造 HTTP 请求时设置参数；</li>
</ol>
<h4 id="CallAdapter和Converter到底是干什么的？"><a href="#CallAdapter和Converter到底是干什么的？" class="headerlink" title="CallAdapter和Converter到底是干什么的？"></a>CallAdapter和Converter到底是干什么的？</h4><p>这里多插两句，给大家解释一下这个<code>CallAdapter</code>和<code>Converter</code>到底是干什么的？我们知道，最简单的Retrofit接口一般定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">    <span class="function">Call&lt;ResponseBody&gt; <span class="title">listRepos</span><span class="params">(@Path(<span class="string">"user"</span>)</span> String user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在给Retrofit不添加任何<code>CallAdapterFactory</code>的情况下，接口方法的返回类型必须是<code>Call&lt;?&gt;</code>，不能是其他类型。因而Retrofit提供了对这个Call进行转换为其他类型的功能，那就是<code>CallAdapter</code>。比如添加一个<strong>RxJava</strong>的CallAdapter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.example.com"</span>)</span><br><span class="line">    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())	<span class="comment">// RxJava转换器</span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<p>然后我们就可以这样定义接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function">Observable&lt;User&gt; <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果添加了一个<strong>Java8</strong>的CallAdapter，就可以这样定义接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function">CompletableFuture&lt;User&gt; <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Retrofit提供的CallAdapter："><a href="#Retrofit提供的CallAdapter：" class="headerlink" title="Retrofit提供的CallAdapter："></a>Retrofit提供的CallAdapter：</h5><table>
<thead>
<tr>
<th>CallAdapter</th>
<th>Gradle依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td>guava</td>
<td>com.squareup.retrofit2:adapter-guava:latest.version</td>
</tr>
<tr>
<td>Java8</td>
<td>com.squareup.retrofit2:adapter-java8:latest.version</td>
</tr>
<tr>
<td>rxjava</td>
<td>com.squareup.retrofit2:adapter-rxjava:latest.version</td>
</tr>
<tr>
<td>rxjava2</td>
<td>com.squareup.retrofit2:adapter-rxjava2:latest.version</td>
</tr>
<tr>
<td>scala</td>
<td>com.squareup.retrofit2:adapter-scala:latest.version</td>
</tr>
</tbody>
</table>
<p>同样地，如果在不给Retrofit添加任何<code>ConverterFactory</code>的情况下，接口方法返回类型<code>Call&lt;T&gt;</code>里的泛型<code>T</code>必须是<code>ResponseBody</code>，而不能是其他类型（比如<code>List&lt;User&gt;</code>），这就是<code>Converter</code>的作用，直白点也就是数据解析器，负责把<code>ResponseBody</code>解析成<code>List&lt;User&gt;</code>。</p>
<p>另外，在我们构造 HTTP 请求时，我们传递的参数都是使用的注解类型（诸如 <code>Path</code>，<code>Query</code>，<code>Field</code> 等），那 Retrofit 是如何把我们传递的各种参数都转化为 String 的呢？还是由 <code>Retrofit</code> 类提供<code>Converter</code>！</p>
<p><code>Converter.Factory</code> 除了提供responseBodyConverter，还提供 requestBodyConverter 和 stringConverter，API 方法中除了 <code>@Body</code> 和 <code>@Part</code> 类型的参数，都利用 stringConverter 进行转换，而 <code>@Body</code> 和 <code>@Part</code> 类型的参数则利用 requestBodyConverter 进行转换。</p>
<h5 id="Retrofit提供的Converter"><a href="#Retrofit提供的Converter" class="headerlink" title="Retrofit提供的Converter"></a>Retrofit提供的Converter</h5><table>
<thead>
<tr>
<th>Converter</th>
<th>Gradle依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td>Gson</td>
<td>com.squareup.retrofit2:converter-gson:latest.version</td>
</tr>
<tr>
<td>Guava</td>
<td>com.squareup.retrofit2:converter-guava:latest.version</td>
</tr>
<tr>
<td>Jackson</td>
<td>com.squareup.retrofit2:converter-jackson:latest.version</td>
</tr>
<tr>
<td>Java8</td>
<td>com.squareup.retrofit2:converter-java8:latest.version</td>
</tr>
<tr>
<td>Jaxb</td>
<td>com.squareup.retrofit2:converter-jaxb:latest.version</td>
</tr>
<tr>
<td>Moshi</td>
<td>com.squareup.retrofit2:converter-moshi:latest.version</td>
</tr>
<tr>
<td>Protobuf</td>
<td>com.squareup.retrofit2:converter-protobuf:latest.version</td>
</tr>
<tr>
<td>Scalars</td>
<td>com.squareup.retrofit2:converter-scalars:latest.version</td>
</tr>
<tr>
<td>Wire</td>
<td>com.squareup.retrofit2:converter-wire:latest.version</td>
</tr>
<tr>
<td>Simple XML</td>
<td>com.squareup.retrofit2:converter-simplexml:latest.version</td>
</tr>
</tbody>
</table>
<h4 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h4><p>这里我们再来个小插曲，来看下 Retrofit 是如何确定当前运行的是哪个平台环境的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Platform PLATFORM = findPlatform();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Platform <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PLATFORM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title">findPlatform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"android.os.Build"</span>);		<span class="comment">//通过反射判断平台</span></span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Android();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"java.util.Optional"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Java8();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Platform();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认Platform的callbackExecutor</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(@Nullable Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callbackExecutor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DefaultCallAdapterFactory.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDefaultMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Object <span class="title">invokeDefaultMethod</span><span class="params">(Method method, Class&lt;?&gt; declaringClass, Object object,</span></span></span><br><span class="line"><span class="function"><span class="params">                               @Nullable Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看到，是通过反射判断有没有该类来实现的。比较巧妙，大家可以的学习一下。</p>
<p>而此处的<code>Android</code>和<code>Java8</code>均是Platform的子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Android平台的默认callbackExecutor，实际上就是抛到UI线程去执行回调</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Android平台的默认CallAdapterFactory</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(@Nullable Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            handler.post(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java8的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IgnoreJRERequirement</span> <span class="comment">// Only classloaded and used on Java 8.</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断被调用的method是否Java8的默认方法</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDefaultMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.isDefault();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用默认方法</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function">Object <span class="title">invokeDefaultMethod</span><span class="params">(Method method, Class&lt;?&gt; declaringClass, Object object,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         @Nullable Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// Because the service interface might not be public, we need to use a MethodHandle lookup</span></span><br><span class="line">        <span class="comment">// that ignores the visibility of the declaringClass.</span></span><br><span class="line">        Constructor&lt;Lookup&gt; constructor = Lookup.class.getDeclaredConstructor(Class.class, <span class="keyword">int</span>.class);</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance(declaringClass, -<span class="number">1</span> <span class="comment">/* trusted */</span>)</span><br><span class="line">                .unreflectSpecial(method, declaringClass)</span><br><span class="line">                .bindTo(object)</span><br><span class="line">                .invokeWithArguments(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 8 的interface引入了新的语言特性——默认方法（Default Methods）。大家可以参考这篇文章：<a href="https://blog.csdn.net/u010003835/article/details/76850242" target="_blank" rel="noopener">Java8 默认方法 default method</a></p>
<blockquote>
<p>默认方法允许您添加新的功能到现有库的接口中，并能确保与采用旧版本接口编写的代码的二进制兼容性。</p>
</blockquote>
<p>所以如果在Java8的平台上使用Retrofit的话，Retrofit需要排除我们定义的interface中的这些Default Methods。</p>
<p>在使用<code>Retrofit.Builder</code>实例化得到 <code>Retrofit</code> 对象后就是调用 <code>Retrofit#create()</code> 方法来创建我们 API 接口的实例。</p>
<h4 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h4><p>所以我们需要跟进Retrofit类中的 <code>create(final Class&lt;T&gt; service)</code> 方法来看下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 校验是否为接口，且不能继承其他接口</span></span><br><span class="line">  Utils.validateServiceInterface(service);</span><br><span class="line">  <span class="comment">// 是否需要提前解析接口方法</span></span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    eagerlyValidateMethods(service);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 动态代理模式, 返回一个 service 接口的代理对象</span></span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 将接口中的方法构造为 ServiceMethod</span></span><br><span class="line">          ServiceMethod serviceMethod = loadServiceMethod(method);</span><br><span class="line">          OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">          <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，最关键的就是『动态代理』，返回了一个 Proxy 代理类，调用接口中的任何方法都会调用 proxy 里的 invoke 方法。实际上，进行网络操作的都是通过代理类来完成的。<strong>简单的说，在我们前面的示例代码中调用 <code>GitHubService.listRepos</code> 时，实际上调用的是这里的 <code>InvocationHandler.invoke</code> 方法。</strong></p>
<p> <code>InvocationHandler.invoke</code>这个方法的意思是：如果调用的是 <code>Object</code> 的方法，例如 <code>equals</code>，<code>toString</code>，那就直接调用。如果是 default 方法（Java 8 引入的新语法），就调用 default 方法。这些我们都先不管，因为我们在Android平台调用 <code>listRepos</code>，肯定不是这两种情况，那这次调用真正干活的就是这三行代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将接口中的方法构造为 ServiceMethod</span></span><br><span class="line">ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line"><span class="keyword">return</span> serviceMethod.adapt(okHttpCall);</span><br></pre></td></tr></table></figure>
<p><strong>这三句代码，下面我们着重来看。</strong></p>
<p>在代理中，会根据参数中传入的具体接口方法来构造出对应的 <code>serviceMethod</code> 。<code>ServiceMethod</code> 类的作用就是把接口的方法适配为对应的 HTTP call 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">    <span class="comment">// 先从缓存中取，若没有就去创建对应的 ServiceMethod</span></span><br><span class="line">    ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有缓存就创建，之后再放入缓存中</span></span><br><span class="line">        result = <span class="keyword">new</span> ServiceMethod.Builder&lt;&gt;(<span class="keyword">this</span>, method).build();</span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在内部还维护了一个 <code>serviceMethodCache</code> 来缓存 <code>ServiceMethod</code> ，同一个 API 的同一个方法，只会创建一次。由于我们每次获取 API 实例都是传入的 <code>class</code> 对象（比如示例中的GitHubService.class），而 <code>class</code> 对象是进程内单例的，所以获取到它的同一个方法 <code>Method</code> 实例也是单例的，所以这里的缓存是有效的。我们就直接来看 <code>ServiceMethod</code> 是如何被创建的吧。</p>
<h4 id="ServiceMethod"><a href="#ServiceMethod" class="headerlink" title="ServiceMethod"></a>ServiceMethod</h4><p><code>ServiceMethod&lt;R, T&gt;</code> 类的作用正如其 JavaDoc 所言：</p>
<blockquote>
<p>Adapts an invocation of an interface method into an HTTP call. 把对接口方法的调用转为一次 HTTP 调用。</p>
</blockquote>
<p>一个 <code>ServiceMethod</code> 对象对应于一个 API interface 的一个方法，上面的<code>loadServiceMethod(method)</code>方法负责加载了 <code>ServiceMethod</code>。我们发现 <code>ServiceMethod</code> 也是通过建造者模式（<code>ServiceMethod.Builder</code>）来创建对象的。那就进入对应构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于ServiceMethod类中</span></span><br><span class="line">Builder(Retrofit retrofit, Method method) &#123;</span><br><span class="line">      <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">      <span class="keyword">this</span>.method = method;</span><br><span class="line">      <span class="comment">// 接口方法的注解</span></span><br><span class="line">      <span class="keyword">this</span>.methodAnnotations = method.getAnnotations();</span><br><span class="line">      <span class="comment">// 接口方法的参数类型</span></span><br><span class="line">      <span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">      <span class="comment">// 接口方法参数的注解</span></span><br><span class="line">      <span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造方法中没有什么特别的地方，我们单刀直入 <code>build()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 根据接口方法的注解和返回类型创建 callAdapter</span></span><br><span class="line">      <span class="comment">// 如果没有添加 CallAdapter 那么默认会用 ExecutorCallAdapterFactory</span></span><br><span class="line">      callAdapter = createCallAdapter();</span><br><span class="line">      <span class="comment">// calladapter 的响应类型中的泛型，比如 Call&lt;User&gt; 中的 User</span></span><br><span class="line">      responseType = callAdapter.responseType();</span><br><span class="line">      <span class="keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(<span class="string">"'"</span></span><br><span class="line">                  + Utils.getRawType(responseType).getName()</span><br><span class="line">                  + <span class="string">"' is not a valid response body type. Did you mean ResponseBody?"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 根据之前泛型中的类型以及接口方法的注解创建 ResponseConverter</span></span><br><span class="line">      responseConverter = createResponseConverter();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据接口方法的注解构造请求方法，比如 @GET @POST @DELETE 等</span></span><br><span class="line">      <span class="comment">// 另外还有添加请求头，检查url中有无带?，转化 path 中的参数</span></span><br><span class="line">      <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">          parseMethodAnnotation(annotation);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(<span class="string">"HTTP method annotation is required (e.g., @GET, @POST, etc.)."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 若无 body 则不能有 Multipart 和 FormEncoded 的注解</span></span><br><span class="line">      <span class="keyword">if</span> (!hasBody) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">              <span class="keyword">throw</span> methodError(</span><br><span class="line">                      <span class="string">"Multipart can only be specified on HTTP methods with request body (e.g., @POST)."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">              <span class="keyword">throw</span> methodError(<span class="string">"FormUrlEncoded can only be specified on HTTP methods with "</span></span><br><span class="line">                      + <span class="string">"request body (e.g., @POST)."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 解析接口方法参数中的注解，比如 @Path @Query @QueryMap @Field 等等</span></span><br><span class="line">      <span class="comment">// 相应的，每个方法的参数都创建了一个 ParameterHandler&lt;?&gt; 对象</span></span><br><span class="line">      <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">      parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line">          Type parameterType = parameterTypes[p];</span><br><span class="line">          <span class="keyword">if</span> (Utils.hasUnresolvableType(parameterType)) &#123;</span><br><span class="line">              <span class="keyword">throw</span> parameterError(p, <span class="string">"Parameter type must not include a type variable or wildcard: %s"</span>,</span><br><span class="line">                      parameterType);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</span><br><span class="line">          <span class="keyword">if</span> (parameterAnnotations == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> parameterError(p, <span class="string">"No Retrofit annotation found."</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查构造出的请求有没有不对的地方</span></span><br><span class="line">      <span class="keyword">if</span> (relativeUrl == <span class="keyword">null</span> &amp;&amp; !gotUrl) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(<span class="string">"Missing either @%s URL or @Url parameter."</span>, httpMethod);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(<span class="string">"Non-body HTTP method cannot contain @Body."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(<span class="string">"Form-encoded method must contain at least one @Field."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class="line">          <span class="keyword">throw</span> methodError(<span class="string">"Multipart method must contain at least one @Part."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>build()</code> 中代码挺长的，总结起来就一句话：就是将 API 接口中的方法进行解析，构造成 <code>ServiceMethod</code>，交给下面的 <code>OkHttpCall</code> 使用。</p>
<p>基本上做的事情就是：</p>
<ol>
<li>创建 CallAdapter ；</li>
<li>创建 ResponseConverter；</li>
<li>根据 API 接口方法的注解构造网络请求方法；</li>
<li>根据 API 接口方法参数中的注解构造网络请求的参数；</li>
<li>检查有无异常；</li>
</ol>
<p>下面我们看看第二句重要的代码<code>OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</code></p>
<h4 id="OkHttpCall"><a href="#OkHttpCall" class="headerlink" title="OkHttpCall"></a>OkHttpCall</h4><p><code>OkHttpCall</code> 实现了 <code>retrofit2.Call</code>，我们通常会使用它的 <code>execute()</code> 和 <code>enqueue(Callback&lt;T&gt; callback)</code> 接口。前者用于同步执行 HTTP 请求，后者用于异步执行。我们先看 <code>execute()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    okhttp3.Call call;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (creationFailure != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (IOException) creationFailure;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) creationFailure;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) creationFailure;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        call = rawCall;</span><br><span class="line">        <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 根据 serviceMethod 中的众多数据创建出 Okhttp 中的 Request 对象</span></span><br><span class="line">	            <span class="comment">// 注意的一点，会调用上面的 ParameterHandler.apply 方法来填充网络请求参数</span></span><br><span class="line">	            <span class="comment">// 然后再根据 OkhttpClient 创建出 Okhttp 中的 Call</span></span><br><span class="line">	            <span class="comment">// 这一步也说明了在 Retrofit 中的 OkHttpCall 内部请求最后会转换为 OkHttp 的 Call</span></span><br><span class="line">                call = rawCall = createRawCall();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | RuntimeException | Error e) &#123;</span><br><span class="line">                throwIfFatal(e); <span class="comment">//  Do not assign a fatal error to creationFailure.</span></span><br><span class="line">                creationFailure = e;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">        call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行 call 并转换成响应的 response</span></span><br><span class="line">    <span class="keyword">return</span> parseResponse(call.execute());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>execute()</code> 做的就是将 Retrofit 中的 call 转化为 OkHttp 中的 Call 。最后让 OkHttp 的 Call 去执行。</p>
<p>主要包括三步：</p>
<ol>
<li>调用<code>createRawCall()</code>创建了 <code>okhttp3.Call</code>，包括构造参数；</li>
<li>使用<code>call.execute()</code>执行网络请求；</li>
<li>解析网络请求返回的数据；</li>
</ol>
<p>我们分别来看看<code>createRawCall()</code>和<code>parseResponse()</code>这两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OkHttpCall类中</span></span><br><span class="line"><span class="keyword">private</span> okhttp3.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    okhttp3.Call call = serviceMethod.toCall(args);</span><br><span class="line">    <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Call.Factory returned null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createRawCall()</code> 函数中，我们调用了 <code>serviceMethod.toCall(args)</code> 来创建 <code>okhttp3.Call</code>，而在后者中，我们之前准备好的 <code>parameterHandlers</code> 就派上了用场。</p>
<p>然后我们再调用 <code>serviceMethod.callFactory.newCall(request)</code> 来创建 <code>okhttp3.Call</code>，这里之前准备好的 <code>callFactory</code> 同样也派上了用场，由于工厂在构造 <code>Retrofit</code> 对象时可以指定，所以我们也可以指定其他的工厂（例如使用过时的 <code>HttpURLConnection</code> 的工厂），来使用其它的底层 HttpClient 实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ResponseBody rawBody = rawResponse.body();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove the body's source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">    rawResponse = rawResponse.newBuilder()</span><br><span class="line">            .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果返回的响应码不是成功的话，返回错误 Response</span></span><br><span class="line">    <span class="keyword">int</span> code = rawResponse.code();</span><br><span class="line">    <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">            ResponseBody bufferedBody = Utils.buffer(rawBody);</span><br><span class="line">            <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rawBody.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果返回的响应码是204或者205，返回没有 body 的成功 Response</span></span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) &#123;</span><br><span class="line">        rawBody.close();</span><br><span class="line">        <span class="keyword">return</span> Response.success(<span class="keyword">null</span>, rawResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExceptionCatchingRequestBody catchingBody = <span class="keyword">new</span> ExceptionCatchingRequestBody(rawBody);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将 body 转换为对应的泛型，然后返回成功 Response</span></span><br><span class="line">        T body = serviceMethod.toResponse(catchingBody);</span><br><span class="line">        <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></span><br><span class="line">        <span class="comment">// a runtime exception.</span></span><br><span class="line">        catchingBody.throwIfCaught();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们调用 <code>okhttp3.Call#execute()</code> 来执行网络请求，这个方法是阻塞的，执行完毕之后将返回收到的响应数据。收到响应数据之后，我们进行了状态码的检查，通过检查之后我们调用了 <code>serviceMethod.toResponse(catchingBody)</code> 来把响应数据转化为了我们需要的数据类型对象T。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceMethod类中</span></span><br><span class="line"><span class="function">R <span class="title">toResponse</span><span class="params">(ResponseBody body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> responseConverter.convert(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>serviceMethod</code> 的<code>toResponse</code> 函数中，我们之前准备好的 <code>responseConverter</code> 也派上了用场。我们分别看下：</p>
<ol>
<li><code>responseConverter</code>这个实例哪里来？</li>
<li><code>ResponseConverter</code>的<code>convert()</code>方法干了什么？</li>
</ol>
<h4 id="默认的Converter"><a href="#默认的Converter" class="headerlink" title="默认的Converter"></a>默认的Converter</h4><h5 id="1-responseConverter这个实例哪里来？"><a href="#1-responseConverter这个实例哪里来？" class="headerlink" title="#1. responseConverter这个实例哪里来？"></a>#1. <code>responseConverter</code>这个实例哪里来？</h5><p>在<code>ServiceMethod.Builder</code>类中，我们找到了它的赋值的地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在ServiceMethod.Builder类中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 创建默认的CallAdapter</span></span><br><span class="line">      callAdapter = createCallAdapter();</span><br><span class="line">      responseType = callAdapter.responseType();</span><br><span class="line">      <span class="keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"'"</span></span><br><span class="line">            + Utils.getRawType(responseType).getName()</span><br><span class="line">            + <span class="string">"' is not a valid response body type. Did you mean ResponseBody?"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 创建默认的ResponseConverter</span></span><br><span class="line">      responseConverter = createResponseConverter();</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//...省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，在<code>build()</code>方法中同时创建了默认的CallAdapter和ResponseConverter。我们先继续前往<code>createResponseConverter</code>关注ResponseConverter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Converter&lt;ResponseBody, T&gt; <span class="title">createResponseConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">        <span class="keyword">throw</span> methodError(e, <span class="string">"Unable to create converter for %s"</span>, responseType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来是根据我们定义的接口方法的返回类型和注解，交给了Retrofit的<code>responseBodyConverter(Type type, Annotation[] annotations)</code>去找：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">responseBodyConverter</span><span class="params">(Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextResponseBodyConverter(<span class="keyword">null</span>, type, annotations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">nextResponseBodyConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">    checkNotNull(type, <span class="string">"type == null"</span>);</span><br><span class="line">    checkNotNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据接口方法的返回类型、注解等信息找到对应的ResponseConverter</span></span><br><span class="line">    <span class="keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">                converterFactories.get(i).responseBodyConverter(type, annotations, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找不到任何ResponseConverter的话，就抛异常</span></span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"Could not locate ResponseBody converter for "</span>)</span><br><span class="line">            .append(type)</span><br><span class="line">            .append(<span class="string">".\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (skipPast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        builder.append(<span class="string">"  Skipped:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start; i++) &#123;</span><br><span class="line">            builder.append(<span class="string">"\n   * "</span>).append(converterFactories.get(i).getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">"  Tried:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        builder.append(<span class="string">"\n   * "</span>).append(converterFactories.get(i).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>Retrofit</code> 类内部，将遍历一个 <code>converterFactories</code> 列表，让工厂们提供，如果最终没有工厂能（根据 <code>returnType</code> 和 <code>annotations</code>）提供需要的 <code>ResponseConverter</code>，那将抛出异常。而这个工厂列表我们可以在构造 <code>Retrofit</code> 对象时进行添加。</p>
<p>还记得我们在使用<code>Retrofit.Builder</code>构造Retrofit对象的时候，默认添加的<code>converterFactory</code>吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//...省略其他代码...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">      <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">      converterFactories.add(<span class="keyword">new</span> BuiltInConverters());		<span class="comment">// 默认的Converter</span></span><br><span class="line">      converterFactories.addAll(<span class="keyword">this</span>.converterFactories);   <span class="comment">// 我们自定义的Converter</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-ResponseConverter的convert-方法干了什么？"><a href="#2-ResponseConverter的convert-方法干了什么？" class="headerlink" title="#2. ResponseConverter的convert()方法干了什么？"></a>#2. <code>ResponseConverter</code>的<code>convert()</code>方法干了什么？</h5><p>我们看看这个内置转换器（<code>BuildInConverters</code>）是什么东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BuiltInConverters</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">        <span class="comment">// 内置的BuiltInConverters直接返回ResponseBody或者Void类型</span></span><br><span class="line">        <span class="keyword">if</span> (type == ResponseBody.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Utils.isAnnotationPresent(annotations, Streaming.class)</span><br><span class="line">                    ? StreamingResponseBodyConverter.INSTANCE</span><br><span class="line">                    : BufferingResponseBodyConverter.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type == Void.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> VoidResponseBodyConverter.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class="line">                                                          Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) &#123;</span><br><span class="line">            <span class="keyword">return</span> RequestBodyConverter.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...省略其他代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamingResponseBodyConverter</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">ResponseBody</span>&gt; </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> StreamingResponseBodyConverter INSTANCE = <span class="keyword">new</span> StreamingResponseBodyConverter();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> ResponseBody <span class="title">convert</span><span class="params">(ResponseBody value)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 直接返回，不进行任何处理</span></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内置的<code>BuiltInConverters</code>会直接返回<code>ResponseBody</code>或者<code>Void</code>类型，不做其他任何的转换操作，所以如果我们不添加任何ConverterFactory的默认情况下，我们定义的接口方法返回类型只能接受<code>ResponseBody</code>或者<code>Void</code>这两种类型。</p>
<h4 id="默认的CallAdapter"><a href="#默认的CallAdapter" class="headerlink" title="默认的CallAdapter"></a>默认的CallAdapter</h4><p>下面，我们来看下那三句重要代码中的最后一句<code>return serviceMethod.adapt(okHttpCall);</code>。ServiceMethod类中的<code>adapt()</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceMethod类中</span></span><br><span class="line"><span class="function">T <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们分别看下：</p>
<ol>
<li>这个<code>callAdapter</code>实例哪里来的？</li>
<li><code>CallAdapter</code>类的<code>adapt()</code>方法干了什么？</li>
</ol>
<h5 id="1-这个callAdapter实例哪里来的？"><a href="#1-这个callAdapter实例哪里来的？" class="headerlink" title="#1. 这个callAdapter实例哪里来的？"></a>#1. 这个<code>callAdapter</code>实例哪里来的？</h5><p>这个<code>callAdapter</code>实例是在哪里赋值的呢，我们找到了<code>ServiceMethod.Builder</code>的<code>build()</code>方法，可以回到上面看看这个方法的源码，可以看到它是调用了<code>createCallAdapter</code>这个方法创建的，如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceMethod.Builder类中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CallAdapter&lt;T, R&gt; <span class="title">createCallAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Type returnType = method.getGenericReturnType();</span><br><span class="line">    <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(</span><br><span class="line">                <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接口方法返回的类型不能是void</span></span><br><span class="line">    <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(<span class="string">"Service methods cannot return void."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        <span class="keyword">return</span> (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">        <span class="keyword">throw</span> methodError(e, <span class="string">"Unable to create call adapter for %s"</span>, returnType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>callAdapter</code> 还是由 <code>Retrofit</code> 类提供的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">    <span class="keyword">return</span> nextCallAdapter(<span class="keyword">null</span>, returnType, annotations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; nextCallAdapter(<span class="meta">@Nullable</span> CallAdapter.Factory skipPast, Type returnType,</span><br><span class="line">                                         Annotation[] annotations) &#123;</span><br><span class="line">    checkNotNull(returnType, <span class="string">"returnType == null"</span>);</span><br><span class="line">    checkNotNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据接口方法的返回类型、注解等信息找到对应的CallAdapter</span></span><br><span class="line">    <span class="keyword">int</span> start = callAdapterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> adapter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找不到任何CallAdapter，抛异常</span></span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"Could not locate call adapter for "</span>)</span><br><span class="line">            .append(returnType)</span><br><span class="line">            .append(<span class="string">".\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (skipPast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        builder.append(<span class="string">"  Skipped:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start; i++) &#123;</span><br><span class="line">            builder.append(<span class="string">"\n   * "</span>).append(callAdapterFactories.get(i).getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">"  Tried:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        builder.append(<span class="string">"\n   * "</span>).append(callAdapterFactories.get(i).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>Retrofit</code> 类内部，将遍历一个 <code>CallAdapter.Factory</code> 列表，让工厂们提供，如果最终没有工厂能（根据 <code>returnType</code> 和 <code>annotations</code>）提供需要的 <code>CallAdapter</code>，那将抛出异常。而这个工厂列表我们可以在构造 <code>Retrofit</code> 对象时进行添加。</p>
<p>还记得我们在使用<code>Retrofit.Builder</code>构造Retrofit对象的时候，默认添加的<code>CallAdapterFactory</code>吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Retrofit.Builder类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//...省略其他代码...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></span><br><span class="line">      List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">      <span class="comment">// 添加默认的CallAdapterFactory</span></span><br><span class="line">      callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">      <span class="comment">//...省略其他代码...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而此时的Platform是<code>Android</code>，回顾一下Android的默认CallAdapterFactory：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现了默认的CallAdapterFactory</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(@Nullable Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        handler.post(r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到默认的是<code>ExecutorCallAdapterFactory</code>这个工厂类，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">    ExecutorCallAdapterFactory(Executor callbackExecutor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关注一下这个get()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Type responseType = Utils.getCallResponseType(returnType);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> responseType;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>ExecutorCallAdapterFactory</code>这个工厂类通过<code>get()</code>方法new了一个<code>CallAdapter</code>。然后来看看第二个问题。</p>
<h5 id="2-CallAdapter类的adapt-方法干了什么？"><a href="#2-CallAdapter类的adapt-方法干了什么？" class="headerlink" title="#2. CallAdapter类的adapt()方法干了什么？"></a>#2. <code>CallAdapter</code>类的<code>adapt()</code>方法干了什么？</h5><p>好了，搞清楚了<code>callAdapter</code>的来历，我们看看它的<code>adapt()</code>方法。从上面的分析我们知道，这个<code>CallAdapter</code>类的<code>adapt()</code>方法返回了一个<code>ExecutorCallbackCall</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">final</span> Call&lt;T&gt; delegate;  <span class="comment">// delegate 就是构造器中传进来的 OkHttpCall</span></span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">        <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">        checkNotNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">        delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">                callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> </span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">                            <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span></span><br><span class="line">                            callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">                callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> </span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delegate.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看见这个默认的<code>ExecutorCallbackCall</code>仅仅是把结果回调CallBack放到了对应的<code>CallbackExecutor</code>去执行，并没有对结果进行任何加工。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>一般客户端向服务器请求API，总共分三步：</p>
<ol>
<li>build request(API参数配置)</li>
<li>executor(这里可以有很多变体，比如有无队列，进出顺序，线程管理)</li>
<li>parse callback(解析数据，返回T给上层)</li>
</ol>
<p>如今的retrofit也是换汤不换药的。也是这三步：</p>
<ol>
<li>通过定义interface和使用注解来配置API参数</li>
<li><code>CallAdapter</code>(你可以把它理解成executor)</li>
<li><code>Converter</code>(解析数据并转换成T)</li>
</ol>
<p><img src="/gallery/android_common/625299-29a632638d9f518f.png" alt=""></p>
<p>Retrofit采用了<strong>外观模式</strong>统一调用创建网络请求接口实例和网络请求参数配置的方法，具体细节是：</p>
<ul>
<li>动态创建网络请求接口的实例<strong>（代理模式 - 动态代理）</strong></li>
<li>创建 <code>serviceMethod</code> 对象<strong>（建造者模式 &amp; 单例模式（缓存机制））</strong></li>
<li>对 <code>serviceMethod</code> 对象进行网络请求参数配置：通过解析网络请求接口方法的参数、返回值和注解类型，从Retrofit对象中获取对应的网络请求的url地址、网络请求执行器、网络请求适配器 &amp; 数据转换器。<strong>（策略模式）</strong></li>
<li>对 <code>serviceMethod</code> 对象加入线程切换的操作，便于接收数据后通过Handler从子线程切换到主线程从而对返回数据结果进行处理<strong>（装饰模式）</strong></li>
<li>最终创建并返回一个<code>OkHttpCall</code>类型的网络请求对象</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://gist.github.com/hachy/82d0f7f1a93d80b12fd8" target="_blank" rel="noopener">Retrofit - Sample</a></li>
<li><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/" target="_blank" rel="noopener">拆轮子系列：拆 Retrofit</a></li>
<li><a href="http://wensibo.top/2017/09/05/retrofit/" target="_blank" rel="noopener">Retrofit2.0源码解析</a></li>
<li><a href="https://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="noopener">Retrofit分析-漂亮的解耦套路</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/21662195" target="_blank" rel="noopener">「Android技术汇」Retrofit2 源码解析和案例说明</a></li>
<li><a href="https://segmentfault.com/a/1190000005638577" target="_blank" rel="noopener">深入浅出 Retrofit，这么牛逼的框架你们还不来看看？</a></li>
<li><a href="https://www.jianshu.com/p/308f3c54abdd" target="_blank" rel="noopener">你真的会用Retrofit2吗?Retrofit2完全教程</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>

<script src="../../../../js/vdonate.js"></script>
<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: '打赏支持', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/site/source/about/donate/images/WeChanQR.png',
  alipayImage: 'https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/site/source/about/donate/images/AliPayQR.jpg'
});
</script>
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>本文作者:  </strong>Mr.Seven</a>
          </li>
          <li class="post-copyright-link">
          <strong>本文链接:  </strong>
          <a href="/2018/04/10/【Android】Retrofit源码分析/" target="_blank" title="【Android】Retrofit源码分析">http://github.com/2018/04/10/【Android】Retrofit源码分析/</a>
          </li>
          <li class="post-copyright-license">
            <strong>版权声明:   </strong>
            本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            许可协议。转载请注明出处
          </li>
         
        </ul>
<div>

      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/源码分析/">源码分析</a></li></ul>

      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../../../05/04/【Java】Thread类中的join()方法原理/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          【Java】Thread类中的join()方法原理
        
      </div>
    </a>
  
  
    <a href="../../06/【Android】App应用前后台切换的一种监听方法/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">【Android】App应用前后台切换的一种监听方法</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Retrofit简介"><span class="nav-number">1.</span> <span class="nav-text">Retrofit简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用步骤"><span class="nav-number">2.</span> <span class="nav-text">使用步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-定义Interface"><span class="nav-number">2.1.</span> <span class="nav-text">1. 定义Interface</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-创建Retrofit实例"><span class="nav-number">2.2.</span> <span class="nav-text">2. 创建Retrofit实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-发起请求"><span class="nav-number">2.3.</span> <span class="nav-text">3. 发起请求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码分析"><span class="nav-number">3.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Retrofit-Builder"><span class="nav-number">3.1.</span> <span class="nav-text">Retrofit.Builder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CallAdapter和Converter到底是干什么的？"><span class="nav-number">3.2.</span> <span class="nav-text">CallAdapter和Converter到底是干什么的？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Retrofit提供的CallAdapter："><span class="nav-number">3.2.1.</span> <span class="nav-text">Retrofit提供的CallAdapter：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Retrofit提供的Converter"><span class="nav-number">3.2.2.</span> <span class="nav-text">Retrofit提供的Converter</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Platform"><span class="nav-number">3.3.</span> <span class="nav-text">Platform</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Retrofit"><span class="nav-number">3.4.</span> <span class="nav-text">Retrofit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ServiceMethod"><span class="nav-number">3.5.</span> <span class="nav-text">ServiceMethod</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OkHttpCall"><span class="nav-number">3.6.</span> <span class="nav-text">OkHttpCall</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#默认的Converter"><span class="nav-number">3.7.</span> <span class="nav-text">默认的Converter</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-responseConverter这个实例哪里来？"><span class="nav-number">3.7.1.</span> <span class="nav-text">#1. responseConverter这个实例哪里来？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-ResponseConverter的convert-方法干了什么？"><span class="nav-number">3.7.2.</span> <span class="nav-text">#2. ResponseConverter的convert()方法干了什么？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#默认的CallAdapter"><span class="nav-number">3.8.</span> <span class="nav-text">默认的CallAdapter</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-这个callAdapter实例哪里来的？"><span class="nav-number">3.8.1.</span> <span class="nav-text">#1. 这个callAdapter实例哪里来的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-CallAdapter类的adapt-方法干了什么？"><span class="nav-number">3.8.2.</span> <span class="nav-text">#2. CallAdapter类的adapt()方法干了什么？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计模式"><span class="nav-number">4.</span> <span class="nav-text">设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考资料"><span class="nav-number">5.</span> <span class="nav-text">参考资料</span></a></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2019 iTimeTraveler All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |  
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="../../../../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../../../../archives" class="mobile-nav-link">Archives</a>
  
    <a href="../../../../categories" class="mobile-nav-link">Categories</a>
  
    <a href="../../../../tags" class="mobile-nav-link">Tags</a>
  
    <a href="../../../../funnysite" class="mobile-nav-link">酷站</a>
  
    <a href="../../../../collection" class="mobile-nav-link">收藏</a>
  
    <a href="../../../../about" class="mobile-nav-link">About</a>
  
    <a href="../../../../mybooks" class="mobile-nav-link">🎁</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="../../../../fancybox/jquery.fancybox.css">
  <script src="../../../../fancybox/jquery.fancybox.pack.js"></script>


<script src="../../../../js/scripts.js"></script>




  <script src="../../../../js/dialog.js"></script>








	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            iTimeTraveler
          </div>
          <div class="panel-body">
            Copyright © 2019 Mr.Seven All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>